import * as V from "../src/number"
import { toFromJSON } from "./moreutil"
import * as T from "./testutil"

test('number to JSON', () => {
    let ty = V.NUM()
    toFromJSON(ty, 123, 123)
    toFromJSON(ty, -12.34, -12.34)
    toFromJSON(ty, Number.POSITIVE_INFINITY, "Inf")
    toFromJSON(ty, Number.NEGATIVE_INFINITY, "-Inf")
    toFromJSON(ty, Number.NaN, "NaN")
    toFromJSON(ty, Number.EPSILON, Number.EPSILON)
    toFromJSON(ty, -Number.EPSILON, -Number.EPSILON)
    // Bad JSON
    T.throws(() => ty.toJSON("foo" as any))
    T.throws(() => ty.fromJSON("foo"))
    T.eq(ty.toSimplified(123), 123)
})

test('number clamped', () => {
    let ty = V.NUM().clamp(0, 10)
    T.be(ty.input(5), 5)
    T.be(ty.input(1), 1)
    T.be(ty.input(0), 0)
    T.be(ty.input(-1), 0)
    T.be(ty.input(Number.EPSILON), Number.EPSILON)
    T.be(ty.input(10), 10)
    T.be(ty.input(10 + Number.EPSILON), 10)
    T.be(ty.input(123), 10)
    ty = V.NUM().clamp(undefined, 10)
    T.be(ty.input(-5), -5)
    T.be(ty.input(5), 5)
    T.be(ty.input(15), 10)
    ty = V.NUM().clamp(0, undefined)
    T.be(ty.input(-5), 0)
    T.be(ty.input(5), 5)
    T.be(ty.input(15), 15)
})

test('number as integer', () => {
    let ty = V.NUM().int()
    T.be(ty.input(5), 5)
    T.be(ty.input(1), 1)
    T.be(ty.input(0), 0)
    T.be(ty.input(-1), -1)
    T.throws(() => ty.input(1.5))
    T.throws(() => ty.input(1.0001))
    T.throws(() => ty.input(Number.EPSILON))
    T.throws(() => ty.input(1e30))
    T.throws(() => ty.input(Number.POSITIVE_INFINITY))
    T.throws(() => ty.input(Number.NEGATIVE_INFINITY))
    T.throws(() => ty.input(Number.NaN))
})

test('number as non-negative integer', () => {
    let ty = V.NUM().int().min(0)
    T.be(ty.input(5), 5)
    T.be(ty.input(1), 1)
    T.be(ty.input(0), 0)
    T.throws(() => ty.input(-1))
    T.throws(() => ty.input(1.5))
    T.throws(() => ty.input(-1.5))
    T.throws(() => ty.input(1.0001))
    T.throws(() => ty.input(Number.EPSILON))
    T.throws(() => ty.input(1e30))
    T.throws(() => ty.input(Number.POSITIVE_INFINITY))
    T.throws(() => ty.input(Number.NEGATIVE_INFINITY))
    T.throws(() => ty.input(Number.NaN))
})